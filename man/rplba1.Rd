% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R, R/lba.R
\name{rplba1}
\alias{rplba1}
\alias{rplba2}
\alias{rplba3}
\alias{rplbaR1}
\alias{rplbaR2}
\alias{rplbaR3}
\title{Generate Random Choice Response Times using pLBA Model}
\usage{
rplba1(n, pVec)

rplba2(n, pVec)

rplba3(n, pVec)

rplbaR1(n = 10, pVec = c(A = 1.51, b = 2.7, v1 = 3.32, v2 = 2.24, w1 = 1.51,
  w2 = 3.69, sv = 1, rD = 0.31, swt = 0.5, t0 = 0.08))

rplbaR2(n = 10, pVec = c(A1 = 1.51, A2 = 1.51, b1 = 2.7, b2 = 2.7, v1 =
  3.32, v2 = 2.24, w1 = 1.51, w2 = 3.69, sv1 = 1, sv2 = 1, sw1 = 1, sw2 = 1, rD
  = 0.31, swt = 0.5, t0 = 0.08))

rplbaR3(n, pVec = c(A1 = 1.5, A2 = 1.5, B1 = 1.2, B2 = 1.2, C1 = 0.3, C2 =
  0.3, v1 = 3.32, v2 = 2.24, w1 = 1.51, w2 = 3.69, sv1 = 1, sv2 = 1, sw1 = 1,
  sw2 = 1, rD = 0.3, tD = 0.3, swt = 0.5, t0 = 0.08))
}
\arguments{
\item{n}{number of observations. Must be an integer}

\item{pVec}{a numeric vector storing pLBA model parameters. The sequence is
critical. For \code{rplba1}, it is, A, b, v1, v2, w1, w2, sv, rD, swt, and 
t0. For \code{rplba2}, it is A1, A2, b1, b2, v1, v2, w1, w2, sv1, sv2, sw1, sw2,
rD, swt, and t0.}
}
\value{
A \code{n x 2} matrix with a first column storing choices and second 
column storing response times.
}
\description{
This function uses two-accumulator piecewise LBA model to generate random 
choice RTs. There are 4 variants: \code{rplbaR1}, 
\code{rplbaR2}, \code{rplba1}, and \code{rplba2}. The former two implement
in R script and the latter two implement in C++.
}
\details{
\code{rplba1} and \code{rplbaR1} use the following parameterisation: 
\itemize{
\item \bold{\emph{A}} start-point interval. \code{A} is the upper bound 
of the interval \code{[0, A]}. An uniform distribution with bound, 
\code{[0, A]} is used to generate a start point. Average amount of prior 
evidence (i.e., before accumulation process even begins) across trials is 
\code{A/2}. 
\item \bold{\emph{b}} response threshold. \code{b-A/2} is a measure of 
average \emph{response caution}.
\item \bold{\emph{v1}} accumulator 1 drift rate, stage 1
\item \bold{\emph{v2}} accumulator 2 drift rate, stage 1
\item \bold{\emph{w1}} accumulator 1 drift rate, stage 2
\item \bold{\emph{w2}} accumulator 2 drift rate, stage 2
\item \bold{\emph{sv}} a common standard deviation for all drift rates 
(muv1, muw1, muv2, muw2). 
\item \bold{\emph{rD}} a delay period while drift rate switch to a 
second stage process   
\item \bold{\emph{t0}} non-decision time in second. 
\item \bold{\emph{swt}} switch time, usually determined by experimental 
design.
}

\code{rplba2} and \code{rplbaR2} use the following parameterisation:

\itemize{
\item \bold{\emph{A1}} start-point interval of the accumulator 1. 
\item \bold{\emph{A2}} start-point interval of the accumulator 2. 
\item \bold{\emph{b1}} accumulator 1 response threshold. 
\item \bold{\emph{b2}} accumulator 2 response threshold. 
\item \bold{\emph{v1}} accumulator 1 drift rate, stage 1
\item \bold{\emph{v2}} accumulator 2 drift rate, stage 1
\item \bold{\emph{w1}} accumulator 1 drift rate, stage 2
\item \bold{\emph{w2}} accumulator 2 drift rate, stage 2
\item \bold{\emph{sv1}} the standard deviation of accumulator 1 drirt rate
during stage 1. 
\item \bold{\emph{sv2}} the standard deviation of accumulator 2 drirt rate
during stage 1. 
\item \bold{\emph{sw1}} the standard deviation of accumulator 1 drirt rate
during stage 2. 
\item \bold{\emph{sw2}} the standard deviation of accumulator 2 drirt rate
during stage 2. 
\item \bold{\emph{rD}} a delay period while drift rate switch to a 
second stage process   
\item \bold{\emph{swt}} switch time, usually determined by experimental 
design
\item \bold{\emph{t0}} non-decision time in second. 
}
}
\examples{
## pVec stands for parameter vector
n <- 1e5
pVec1 <- c(A=1.51, b=2.7, v1=3.32, v2=2.24,  w1=1.51,  w2=3.69,  
           sv=1, rD=0.31, swt=0.5, t0=0.08)
 
pVec2 <- c(A1=1.51, A2=1.51, b1=2.7, b2=2.7, v1=3.32, v2=2.24,
           w1=1.51, w2=3.69, sv1=1, sv2=1, sw1=1, sw2=1, rD=0.31, 
           swt=0.5, t0=0.08)
           
system.time(dat1 <- cpda::rplba1(n, pVec1))
system.time(dat2 <- cpda::rplba2(n, pVec2))
system.time(dat3 <- cpda::rplbaR1(n, pVec1))
system.time(dat4 <- cpda::rplbaR2(n, pVec2))

## Their density plots do match, if n is set large (1e5).
tmp1 <- data.frame(choice=factor(dat1[,1]), rt=dat1[,2])
tmp2 <- data.frame(choice=factor(dat2[,1]), rt=dat2[,2])
tmp3 <- data.frame(choice=factor(dat3[,1]), rt=dat3[,2])
tmp4 <- data.frame(choice=factor(dat4[,1]), rt=dat4[,2])
tmp1$fun <- "rplba1"
tmp2$fun <- "rplba2"
tmp3$fun <- "rplba1-R"
tmp4$fun <- "rplba2-R"
df     <- rbind(tmp1, tmp2, tmp3, tmp4)
df$fun <- factor(df$fun)

require(lattice)
histogram(~rt | fun + choice , data=df, breaks="fd", type="density", 
             xlab="Response Time (s)", 
             panel=function(x, ...) {
               panel.histogram(x, ...)
               panel.densityplot(x, darg=list(kernel="gaussian"),...)
})
  
cb <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", 
        "#0072B2", "#D55E00", "#CC79A7")
        
require(ggplot2)
ggplot(data=df, aes(x=rt, fill=fun, color=fun)) +
    geom_density(alpha=0.2) +
    facet_wrap(~ choice) +
    xlab("RT (s)") + ylab("Density") +
    scale_fill_manual(values=cb)
    
## Use hist to plot one after another    
hist(tmp1$rt, breaks="fd", freq=FALSE, , xlab="RT (s)", main="pLBA")
lines(density(tmp2$rt), col="lightblue", lty="dashed",   lwd=1.5)
lines(density(tmp3$rt), col="orange",    lty="dotdash",  lwd=2)
lines(density(tmp4$rt), col="darkgreen", lty="longdash", lwd=2.5)
}

