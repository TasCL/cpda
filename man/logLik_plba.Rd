% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{logLik_plba}
\alias{logLik_plba}
\alias{logLik_plba2}
\title{Compute Summed Log-likelihood for a pLBA Model}
\usage{
logLik_plba(object, pVec, ns = 100000L, h = 0, m = 0.8, p = 10)

logLik_plba2(object, pVec, ns = 100000L, h = 0, m = 0.8, p = 10)
}
\arguments{
\item{object}{a matrix storing empirical choice RT data. First column must
stores choices and second column stores RTs in seconds.}

\item{pVec}{a vector storing pLBA model parameters. The sequence is 
critical. it is A1, A2, b1, b2, v1, v2, w1, w2, sv1, sv2, sw1, sw2,
rD, swt, and t0.}

\item{ns}{number of simulations. Default is 1e5.}

\item{h}{KDE bandwidth. If not input been enter, the default is 
Sliverman's rule of thumb; otherwise the function uses the input from
the user;}

\item{m}{a multiplier to adjust proportationally h. Default is 0.8}

\item{p}{a precision parameter defines the number of grid as power of 2.
Default value is 10 (i.e., 2^10).}
}
\value{
a summed, logged likelihood across trials and accumulators. 
\code{logLik_plba2} returns three more elements.
}
\description{
This is a wrapper function to approximate a pLBA distribution, using
KDE-FFT method. To retrieve more outputs, use \code{logLik_plba2}.
}
\details{
\code{logLik_plba2} is identical to \code{logLik_plba}, except returning 
four elements:

\itemize{
\item \bold{\emph{LL}}, summed, logged likelihood. This is the same as the 
return value from \code{logLik_plba}. 
\item \bold{\emph{PDF}}, a numeric vector storing \emph{logged}  
probability densities for individual data point.
\item \bold{\emph{z}}, a numeric vector storing centre points of the 
simulated histogram (i.e., grid centre)
\item \bold{\emph{PDF_hist}} a numeric vector stoing the count of simulated
data point in each bin 
}
}
\examples{
 
###################
## Example 1     ##
###################
## I demonstrate how to use the build-in logLik_plba to calculate
## pLBA densities. set.seed(123) is to produce the same result.
rm(list=ls())
pVec <- c(A1=1.51, A2=1.51, b1=2.7, b2=2.7, v1=3.32, v2=2.24,
            w1=1.51, w2=3.69, sv1=1, sv2=1, sw1=1, sw2=1, rD=0.31, 
            swt=0.5, t0=0.08)
  
data(lba)
d$Response <- ifelse(d$Response==0, 1, 2)
dMat <- data.matrix(d); head(dMat)
n <- 1e5
  
set.seed(123)
ll0 <- cpda::logLik_plba(dMat, pVec, 1e5, h=h, m=1); ll0
      
set.seed(123)
llList <- cpda::logLik_plba2(dMat, pVec, 1e5, h=h, m=1); str(llList)
## List of 4
## $ LL      : num 327
## $ PDF     : num [1:1000, 1:4] 1 1 1 1 1 1 1 1 1 1 ...
## $ z       : num [1:2048, 1] 0.13 0.135 0.14 0.146 0.151 ...
## $ PDF_hist: num [1:2048, 1] 0 0 0 0 0 ...
        
###################
## Example 2     ##
###################
## Secondly, I demonstrate use rplba2 and logLik_fft to produce identical 
## result
rm(list=ls())
x <- cbind(rep(1:2,each=100),rep(seq(.5,2,length.out=100),2))
pVec <- c(A1=1.51, A2=1.51, b1=2.7, b2=2.7, v1=3.32, v2=2.24,
            w1=1.51, w2=3.69, sv1=1, sv2=1, sw1=1, sw2=1, rD=0.31, 
            swt=0.5, t0=0.08)
dt1 <- x[x[,1]==1,2] - pVec[15]
dt2 <- x[x[,1]==2,2] - pVec[15]

set.seed(123)
n <- 1e5
samp <- cpda::rplba2(n, pVec); head(samp)
dt1_ <- samp[samp[,1]==1,2] - pVec[15]
dt2_ <- samp[samp[,1]==2,2] - pVec[15]
logLik_fft(dt1, dt1_) + logLik_fft(dt2, dt2_)
  
set.seed(123)
cpda::logLik_plba(x, pVec)
  
fft1 <- cpda::logLik_plba2(x, pVec)
str(fft1)

## choice RT PDF
tmp0 <- fft1$PDF[fft1$PDF[,1] == 1, 2]
tmp1 <- sort(x[x[,1]==1,2])
all(tmp0==tmp1)
  
tmp3 <- fft1$PDF[fft1$PDF[,1] == 2,2]
tmp4 <- sort(x[x[,1]==1,2])
all(tmp3==tmp4)
              
}

