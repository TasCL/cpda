% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{lik_fft}
\alias{lik_fft}
\title{Compute Likelihood, using FFT method}
\usage{
lik_fft(y, yhat, h = 0, m = 0.8, p = 10, n = 0L)
}
\arguments{
\item{y}{a vector storing empirical data.}

\item{yhat}{a vector storing simulated data (e.g., \code{rnorm(100)}).}

\item{h}{the bandwidth for kernel density estimation. If not given,
\code{Lik_fft2} will use Sliverman's rule of thumb}

\item{m}{a multiplier to adjust \code{h} proportationally. Default is 0.8.
This applies also when the user enters his/her own bandwidth.}

\item{p}{a precision parameter defines the number of grid as power of 2.
Default value is 10 (i.e., 2^10).}

\item{n}{the number of simulation. When n=0, where the function will count
the numbers of observation in the simulated histogram. If simulating 
a defective distribution, one should enter the simulation numbers.}
}
\value{
A n x 2 matrix. Keep original order without sorting.
}
\description{
\code{lik_fft2} uses an identical algorithm as \code{logLik_fft}, but
return a matrix. Differing from \code{lik_pw}, \code{lik_fft2}
and \code{logLik_fft},
\enumerate{
\item takes Monte Carlo simulations,
\item transforms them to spectral domain using FFT,
\item applies a standard Gaussian kernel to smooth them,
\item transforms them back to signal domain and
\item interpolates linearly the simulation histogram to the observation 
to obtain estimated likelihoods.
}
}
\examples{
###################
## Example 1     ##
###################
x <- seq(-3, 3, length.out=100) ## Data
samp <- rnorm(1e5)              ## Monte Carlo simulation
h <- 0.8*bw.nrd0(samp)          ## Define bandwidth using R's bw.nrd0

## point-wise and fft
pw1  <- lik_pw(x, samp, h=h, m=1)
fft1 <- lik_fft(x, samp, h=h, m=1)

## the tails may be a bit off.
plot(x, pw1, type="l", lty="dotted")
lines(x, fft1[,2], col="darkgreen", lty="dashed")
lines(x, dnorm(x), col="red", lwd=2)

###################
## Example 2     ##
###################
rm(list=ls())
## Assuming that this is empirical data
y <- rtdists::rLBA(1e3, A=.5, b=1, t0=.25, mean_v=c(2.4, 1.2), sd_v=c(1,1))
rt1  <- y[y$response==1,"rt"]
rt2  <- y[y$response==2,"rt"]
srt1 <- sort(rt1)
srt2 <- sort(rt2)

xlabel <- "RT"; ylabel <- "Density"
par(mfrow=c(1,2))
hist(rt1, "fd", freq=F, xlim=c(0.1,1.5), main="Choice 1", 
    xlab=xlabel, ylab=ylabel)
hist(rt2, "fd", freq=F, xlim=c(0.1,1.5), main="Choice 2",
    xlab=xlabel, ylab=ylabel)
par(mfrow=c(1,1))

## Now draw simulations from another rLBA
n <- 1e5
samp <- rtdists::rLBA(n, A=.5, b=1, t0=.25, mean_v=c(2.4, 1.2), sd_v=c(1,1))
samp1 <- samp[samp[,2]==1, 1]
samp2 <- samp[samp[,2]==2, 1]
fft1 <- lik_fft(srt1, samp1, n=n)[,2]
fft2 <- lik_fft(srt2, samp2, n=n)[,2]

## Just another way to simulate. This is to compare with gpda
pvec <- c(b=1, A=.5, v1=2.4, v2=1.2, sv1=1, sv2=1, t0=.25)
samp <- cpda::rlba1(n, pvec)
samp1 <- samp[samp[,2]==1, 1]
samp2 <- samp[samp[,2]==2, 1]
fft3 <- lik_fft(srt1, samp1, n=n)[,2]
fft4 <- lik_fft(srt2, samp2, n=n)[,2]

## Calculate theoretical densities
den0 <- rtdists::dLBA(y$rt, y$response, A=.5, b=1, t0=.25, 
   mean_v=c(2.4, 1.2), sd_v=c(1, 1))
   
df0 <- cbind(y, den0)
df1 <- df0[df0[,2]==1,]
df2 <- df0[df0[,2]==2,]
den1 <- df1[order(df1[,1]),3]
den2 <- df2[order(df2[,1]),3]
plot(srt1,  den1, type="l")
lines(srt2, den2)
lines(srt1, fft1, col="red")
lines(srt2, fft2, col="red")
lines(srt1, fft3, col="blue")
lines(srt2, fft4, col="blue")

}
\references{
Holmes, W. (2015). A practical guide to the Probability Density
Approximation (PDA) with improved implementation and error characterization.
\emph{Journal of Mathematical Psychology}, \bold{68-69}, 13--24,
doi: http://dx.doi.org/10.1016/j.jmp.2015.08.006.
}
\seealso{
\code{\link{logLik_pw}}, \code{\link{logLik_fft}},
\code{\link{bw.nrd}}, \code{\link{bandwidth.nrd}}.
}
