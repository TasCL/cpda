%% use JSS class -- use 'nojss' to turn off header
\documentclass[shortnames,nojss,article]{jss}
\usepackage{booktabs,flafter,thumbpdf}
%\VignetteIndexEntry{cpda-introduction}
%\VignetteKeywords{Rcpp, foreign function interface, .Call, C++, R}
%\VignetteDepends{Rcpp}
\SweaveOpts{concordance=FALSE}

\author{Yi-Shin Lin\\University of Tasmania \And
Andrew Heathcote\\University of Tasmania \And
William R. Holmes\\Vanderbilt University}
\Plainauthor{Yi-Shin Lin, Andrew Heathcote, William Holmes}

\title{\proglang{cpda} and \proglang{gpda}: Efficient Computation for
Probability Density Approximation}
\Plaintitle{A Solution for Efficient Computation
of Probability Density Approximation}

\Abstract{
  Probability density approximation (PDA) efficiently calculate
  likelihoods even when their analytic functions are unavailable.  It 
  allows researchers to model compuationally complex biological processes, 
  which in the past were approached by overly simplified
  models. PDA is however computationally demanding.  We implement two
  \proglang{R} packges, \pkg{cpda} and \pkg{gpda}, using \proglang{Armadillo}
  and \proglang{CUDA} to provide a practical and efficient solution
  for Bayesian computation of cognitive computational models. Both packages
  harness the multi-thread nature of modern processing units to enable parallel
  computations with a dozens of CPU cores or thoudands of GPU threads.  Each
  package tackles different sets of computation bottlenecks.  The former
  resolves the bottleneck when few fast CPU cores are efficient to find
  optimal solutions, such running
  multiple Markov chains in parallel, whereas the latter reduces the
  computation times when large numbers (>1e5) of Monte Carlo simultion is
  required to approximate probability densities. We conclude with three
  practical exmaples as a road map for application in cognitive models.
}

\Keywords{\proglang{R}, \proglang{C++}, \proglang{GPU}, kernel density estimate,
Markov chain Monte Carlo, piece-wise Linear Ballistic Accumulator model,
circular drift-diffusion model}
\Plainkeywords{R, C++, GPU, kernel density estimate}

\Volume{40}
\Issue{8}
\Month{April}
\Year{2011}
\Submitdate{2010-11-15}
\Acceptdate{2011-03-21}

\Address{
  Yi-Shin Lin\\
  Division of Psychology, School of Medicine\\
  University of Tasmania \\
  Private Bag 30 Hobart TAS 7005,\\
  Australia\\
  E-mail: \email{yishin.lin@utas.edu.au}\\
  URL: \url{http://www.tascl.org/yi-shin-lin.html}

  Andrew Heathcote\\
  School of Psychology,
  University of Newcastle\\
  Psychology Building,
  University Avenue, Callaghan, 2308,NSW, Australia\\
  E-mail: \email{andrew.heathcote@newcastle.edu.au}\\
  URL: \url{http://www.newcl.org/Heathcote/}

  William Holmes\\
  Department of Physics and Astronomy,
  Vanderbilt University\\
  Nashville, TN 37212, United States of America\\
  E-mail: \email{william.holmes@vanderbilt.edu}\\
}

%% need no \usepackage{Sweave.sty}

<<prelim,echo=FALSE,print=FALSE>>=
library(cpda)
cpda.version <- packageDescription("cpda")$Version
cpda.date <- packageDescription("cpda")$Date
now.date <- strftime(Sys.Date(), "%B %d, %Y")
@
%


\begin{document}

\vspace*{0.25cm}

\section{Introduction}

Simulation-based algorithms (Sisson, Scott, \& Fan, 2011) recently find a new
application in finding likelihood functions. This application is especially
useful when specifying a likelihood function analytically is unlikely or
when evaluating it is computationally prohibitive, a situation
arises sometimes in cognitive and often in neuro-cognitive models. These
algorithms are often referred to as \textit{likelihood-free computation} or
\textit{approximate Bayesian computation} (ABC) (Sisson,
Scott, \& Fan, 2011). Probability density approximation (PDA) is one such
method. Unlike other likelihood-free methods, it
circumvents the difficulty of identifying sufficient summary statistics,
a set of numbers supplying as much information for data as unknown model
parameters (Turner \& Sederberg, 2014). This is crucial, because it is
often unlikely to know whether a set of summary statistics is sufficient when
its likelihood function is unavailable.

PDA however, has two computation bottlenecks.  First is calculating kernel
density estimates (KDE) and second is conducting Monte Carlo (MC) simulations.
The computation problem is aggravated when applying PDA in Bayesian modeling,
because KDE estimations and MC simulations are repeatedly calculated in
multiple Markov chains and iterations. More
importantly, the bottlenecks not only incur computation burdens, but also
closely relate to computation errors, which have to be minimized
(Turner \& Sederberg, 2014). Hence an efficient computation method is critical
not just for reducing time, but also for minimizing errors.

Holmes (2015) derived a fast Fourier-based algorithm to reduce computation
steps to mitigate the first bottleneck.  In short, his
algorithm converts KDE estimation to spectrum domains, rendering convolution
to multiplication operations. This algorithm thereby greatly decreases
computation costs and potential errors in the first bottleneck. The second
bottleneck however is largely unresolved. Here we present software for efficient
PDA computation based on Holmes's algorithm, and Turner and Sederberg's (2014)
suggestion, using three recent computational techniques.  First, we code
PDA in \proglang{Armadillo}, a high efficient \proglang{C++} library for
linear algebra (Sanderson \& Curtin, 2016). Second, we implement
\proglang{Open MP} to harness
multiple-core CPU, as it has become commonplace with a regular
personal computer (PC) equipping at least 4 cores in a central process
unit (CPU). Third, we implement PDA also in Compute Unified Device
Architecture, \proglang{CUDA}, a programming model recognizing the structure of
graphics processing unit (GPU); hence, \pkg{gpda}\footnote{\proglang{gpda} 
stands for GPU-based PDA. Similarly \proglang{cpda} stands fro CPU-based PDA}
package allows a regular PC
user to enjoy computation power of thousands GPU cores.

To ease the installation and usage of the packages, we take advantage of the
infrastructure of the Comprehensive \proglang{R} Archive Network (CRAN).
Specifically, \pkg{cpda} and \pkg{gpda} conform CRAN standard and available at
\url{http://CRAN.R-project.org/package=cpda} and
\url{http://CRAN.R-project.org/package=gpda} with numerous examples in their
help pages. The user can easily install the packages using
\proglang{install.packages} function or GUI interface, such as the one provided
by \textit{RStudio}.

\makeatletter
\if@nojss
  This vignette corresponds to the paper published in the \textsl{Journal of
    Statistical Software}. It is currently still identical to
  the published paper.  Over time, this vignette version may receive minor
  updates. For citations, please use the \cite{JSS:Rcpp} or
  \cite{Eddelbuettel:2013:Rcpp}; details are also provided in \proglang{R} via
  \texttt{citation("Rcpp")}.

  This version corresponds to \pkg{cpda} version \Sexpr{cpda.version} and was
  typeset on \Sexpr{now.date}.
\fi
\makeatother


\subsection{A Simple Example}

We first illustrate a simple example, using the \pkg{cpda} to construct a
simulated probability density function (SPDF) for Gaussian distribution.
Because Gaussian distribution have a analytic probability density function 
(PDF), we can easily verify whether \pkg{cpda} returns SPDF approximating 
the analytic PDF.

%
\begin{Code}
## Testing codes for logLik_pw and logLik_fft2 ---------------------------------
## Simulate Gaussian distribution
require(cpda)
n    <- 1e6
samp <- rnorm(n)
h    <- bw.nrd0(samp); ## bandwidth for KDE smoothing
x    <- seq(-3,3, length.out=100) ## Support

## By default logLik_pw returns point-wise log-likelihood, using
## Turner and Sederberg's (2014) method. That is, logLik_pw uses KDE to
## calculate log-likelihood for each observation with a bandwidth = h * 0.8.

rbenchmark::benchmark(replications=rep(10, 1),
  pw <- logLik_pw(x, samp),
  columns=c('test', 'elapsed', 'replications'))
  
##                     test elapsed replications
## pw <- logLik_pw(x, samp)  23.446           10

## On average, it takes 2.34 seconds to return SPDF with 1,000,000 simulations
str(pw)
## num [1:100] -5.47 -5.27 -5.06 -4.89 -4.71 ...

## Using Holmes' FFT-based algorithm and Armadillo's vectorized computation,
## we can improve computation speed. This is useful for the case
## where observations share the same parameter and when x vector gets bigger

rbenchmark::benchmark(replications=rep(10, 1),
  fft2 <- cpda::logLik_fft2(x, samp)[["PDF"]],
  pw <- logLik_pw(x, samp),
  columns=c('test', 'elapsed', 'replications'))

##                                        test elapsed replications
## fft2 <- cpda::logLik_fft2(x, samp)[["PDF"]]   6.815           10
##                    pw <- logLik_pw(x, samp)  23.533           10

## It take logLik_fft2 about 0.7 second to get a SPDF with 1,000,000
## samples. This is almost 3.5 times faster.

## logLik_pw and logLik_fft2 produce almost identical PDF as the one calculate
## directly from Gaussian likelihood function
plot(x,  exp(pw),       type="l",         lty="dotted")
lines(x, exp(fft2[,2]), col="lightgreen", lty="dotdash")
lines(x, dnorm(x),      col="lightblue",  lty="longdash")

\end{Code}
%


\subsection{Related work}

Integration of \proglang{C++} and \proglang{R} has been addressed by several authors; the earliest
published reference is probably \cite{Bates+DebRoy:2001:C++Classes}.
An unpublished paper by \cite{Java+Gaile+Manly:2007:RCpp} expresses several ideas
that are close to some of our approaches, though not yet fully fleshed out.
The \pkg{Rserve} package \citep{Urbanek:2003:Rserve,CRAN:Rserve} acts as a
socket server for \proglang{R}. On the server side, \pkg{Rserve} translates \proglang{R} data
structures into a binary serialization format and uses TCP/IP for
transfer. On the client side, objects are reconstructed as instances of \proglang{Java}
or \proglang{C++} classes that emulate the structure of \proglang{R} objects.

The packages \pkg{rcppbind} \citep{Liang:2008:rcppbind}, \pkg{RAbstraction}
\citep{Armstrong:2009:RAbstraction} and \pkg{RObjects}
\citep{Armstrong:2009:RObjects} are all implemented using \proglang{C++} templates.
None of them have matured to the point of a CRAN release.
\pkg{CXXR} \citep{Runnalls:2009:CXXR} approaches this topic from the other direction:
Its aim is to completely refactor \proglang{R} on a stronger \proglang{C++} foundation.
\pkg{CXXR} is therefore concerned with all aspects of the \proglang{R} interpreter,
read-eval-print loop (REPL), and threading; object interchange between \proglang{R} and \proglang{C++} is but one
part. A similar approach is discussed by \cite{TempleLang:2009:ModestProposal}
who suggests making low-level internals extensible by package developers in
order to facilitate extending \proglang{R}.
\cite{TempleLang:2009:RGCCTranslationUnit}, using compiler output for
references on the code in order to add bindings and wrappers, offers
a slightly different angle.

\subsection[parallel solution]{Areas of Application}
\label{sec:classic_rcpp}

The core focus of \pkg{Rcpp} has always been on helping the
programmer to more easily add \proglang{C++}-based functions.
Here, we use `function' in the standard mathematical sense of providing
results (output) given a set of parameters or data (input).
This was
facilitated from the earliest releases using \proglang{C++} classes for receiving
various types of \proglang{R} objects, converting them to \proglang{C++} objects and allowing the
programmer to return the results to \proglang{R} with relative ease.

This API therefore supports two typical use cases. First, existing \proglang{R} code
may be replaced by equivalent \proglang{C++} code in order to reap
performance gains.  This case is conceptually easy when there are
(built- or run-time) dependencies on other \proglang{C} or \proglang{C++} libraries.  It typically
involves setting up data and parameters---the right-hand side components of a
function call---before making the call in order to provide the result that is
to be assigned to the left-hand side. Second, \pkg{Rcpp} facilitates calling
functions provided by other libraries. The use resembles the first case but
with an additional level of abstraction: data
and parameters are passed via \pkg{Rcpp} to a function set-up to call code
from an external library.

Apart from this `vertical mode' of calling \proglang{C++} from \proglang{R}, additional
features in the new API also support a more `horizontal mode' of directly
calling \pkg{Rcpp} objects.  This was motivated by the needs of other
projects such as \pkg{RInside} \citep{CRAN:RInside} for easy embedding of \proglang{R}
in \proglang{C++} applications and \pkg{RProtoBuf} \citep{CRAN:RProtoBuf} to
interface with the Protocol Buffers library. This use will be touched upon
in the next section, but a more detailed discussion is outside the scope of
this paper.  Lastly, the more recent additions `\pkg{Rcpp} modules' and `\pkg{Rcpp} sugar'
also expand the use cases; see Section~\ref{sec:ongoing} below.

\section[The Rcpp API]{Implementation}
\label{sec:new_rcpp}

\subsection{A first example}

We can highlight several aspects.
\begin{enumerate}
\item Only a single header file
  \code{Rcpp.h} is needed to use the \pkg{Rcpp} API.
\item \code{RcppExport} is a convenience macro helping with calling a
  \proglang{C} function from \proglang{C++}.
\item Given two
  arguments of type \code{SEXP}, a third is returned (as using only
  \code{SEXP} types for input and output is prescribed by the \code{.Call()}
  interface of the \proglang{R} API).
\item Both inputs are
  converted to \proglang{C++} vector types provided by \pkg{Rcpp} (and we have more to say about these
  conversions below).
\item The
  usefulness of these classes can be seen when we query the vectors directly
  for their size---using the \code{size()} member function---in order to
  reserve a new result type of appropriate length,
  and with the use of the
  \verb|operator[]| to extract and set individual elements of the vector.
\item The computation itself is
  straightforward embedded looping just as in the original examples in the
  `Writing \proglang{R} Extensions' manual \citep{R:Extensions}.
\item The return conversion
  from the \code{NumericVector} to the \code{SEXP} type is also automatic.
\end{enumerate}

We argue that this \pkg{Rcpp}-based usage is much easier to read, write and debug than the
\proglang{C} macro-based approach supported by \proglang{R} itself.



\subsection[Rcpp class hierarchy]{\pkg{Rcpp} class hierarchy}

The \code{Rcpp::RObject} class is the basic class of the new \pkg{Rcpp} API.
An instance of the \code{RObject} class encapsulates an \proglang{R} object
(itself represented by the \proglang{R} type \code{SEXP}), exposes methods that are appropriate for all types
of objects and transparently manages garbage collection.

The most important aspect of the \code{RObject} class is that it is
a very thin wrapper around the \code{SEXP} it encapsulates. The
\code{SEXP} is indeed the only data member of an \code{RObject}. The
\code{RObject} class does not interfere with the way \proglang{R} manages its
memory and does not perform copies of the object into a suboptimal
\proglang{C++} representation. Instead, it merely acts as a proxy to the
object it encapsulates so that methods applied to the \code{RObject}
instance are relayed back to the \code{SEXP} in terms of the standard
\proglang{R} API.

The \code{RObject} class takes advantage of the explicit life cycle of
\proglang{C++} objects to manage exposure of the underlying \proglang{R} object to the
garbage collector. The \code{RObject} effectively treats
its underlying \code{SEXP} as a resource.
The constructor of the \code{RObject} class takes
the necessary measures to guarantee that the underlying \code{SEXP}
is protected from the garbage collector, and the destructor
assumes the responsibility to withdraw that protection.

By assuming the entire responsibility of garbage collection, \pkg{Rcpp}
relieves the programmer from writing boiler plate code to manage
the protection stack with \code{PROTECT} and \code{UNPROTECT} macros.

The \code{RObject} class defines a set of member functions applicable
to any \proglang{R} object, regardless of its type. This ranges from
querying properties of the object (\texttt{isNULL}, \texttt{isObject},
\texttt{isS4}), management of the attributes
(\texttt{attributeNames}, \texttt{hasAttribute}, \texttt{attr}) to
handling of slots\footnote{Member functions dealing with slots
are only applicable to \proglang{S}4 objects; otherwise an exception is thrown.}
(\texttt{hasSlot}, \texttt{slot}).

\subsection{Derived classes}

Internally, an \proglang{R} object must have one type amongst the set of
predefined types, commonly referred to as SEXP types. The `\proglang{R} Internals'
manual \citep{R:Internals} documents these various types.
\pkg{Rcpp} associates a dedicated \proglang{C++} class for most SEXP types, and
therefore only exposes functionality that is relevant to the \proglang{R} object
that it encapsulates.

For example \code{Rcpp::Environment} contains
member functions to manage objects in the associated environment.
Similarly, classes related to vectors---\code{IntegerVector}, \code{NumericVector},
\code{RawVector}, \code{LogicalVector}, \code{CharacterVector},
\code{GenericVector} (also known as \code{List}) and
\code{ExpressionVector}---expose functionality to extract and set values from the vectors.

The following sections present typical uses of \pkg{Rcpp} classes in
comparison with the same code expressed using functions and macros of the \proglang{R} API.

\subsection{Numeric vectors}

The next code snippet is taken from `Writing \proglang{R} Extensions'
\citep[Section 5.9.1]{R:Extensions}. It allocates a \code{numeric} vector of two elements
and assigns some values to it using the \proglang{R} API.
%
\begin{Code}
SEXP ab;
PROTECT(ab = allocVector(REALSXP, 2));
REAL(ab)[0] = 123.45;
REAL(ab)[1] = 67.89;
UNPROTECT(1);
\end{Code}
%
Although this is one of the simplest examples in `Writing \proglang{R} Extensions',
it seems verbose and yet it is not obvious at first sight what is happening.
Memory is allocated by \code{allocVector}; we must also supply it with
the type of data (\code{REALSXP}) and the number of elements.  Once
allocated, the \code{ab} object must be protected from garbage
collection.
Lastly, the \code{REAL} macro returns a pointer to the
beginning of the actual array; its indexing does not resemble either \proglang{R} or
\proglang{C++}.

The code can be simplified using the \code{Rcpp::NumericVector} class:
%
\begin{Code}
Rcpp::NumericVector ab(2);
ab[0] = 123.45;
ab[1] = 67.89;
\end{Code}
%
The code contains fewer idiomatic decorations. The \code{NumericVector}
constructor is given the number of elements the vector contains (2), which
hides the call to the \code{allocVector} in the original code example. Also hidden is
protection of the object from garbage collection, which is a behavior that
\code{NumericVector} inherits from \code{RObject}.  Values are assigned to
the first and second elements of the vector as \code{NumericVector} overloads
the \code{operator[]}.

The snippet can also be written more concisely as a single statement using the \code{create}
static member function of the \code{NumericVector} class:
%
\begin{Code}
Rcpp::NumericVector ab = Rcpp::NumericVector::create(123.45, 67.89);
\end{Code}


\subsection{Character vectors}

A second example deals with character vectors and emulates this \proglang{R} code:
%
\begin{CodeInput}
R> c("foo", "bar")
\end{CodeInput}
%
Using the traditional \proglang{R} API, the vector can be allocated and filled as such:
%
\begin{Code}
SEXP ab;
PROTECT(ab = allocVector(STRSXP, 2));
SET_STRING_ELT( ab, 0, mkChar("foo") );
SET_STRING_ELT( ab, 1, mkChar("bar") );
UNPROTECT(1);
\end{Code}
%
This imposes on the programmer knowledge of \code{PROTECT}, \code{UNPROTECT},
\code{SEXP}, \code{allocVector}, \code{SET\_STRING\_ELT}, and \code{mkChar}.
%
Using the \code{Rcpp::CharacterVector} class, we can express the same
code more concisely:
%
\begin{Code}
Rcpp::CharacterVector ab(2);
ab[0] = "foo";
ab[1] = "bar";
\end{Code}

\section[R and C++ data interchange]{Application I}

In addition to classes, the \pkg{Rcpp} package contains two
functions to perform conversion of \proglang{C++} objects to \proglang{R} objects and back.

\subsection[C++ to R: wrap]{\proglang{C++} to \proglang{R}: \code{wrap}}

The \proglang{C++} to \proglang{R} conversion is performed by the \code{Rcpp::wrap} templated
function. It uses advanced template metaprogramming techniques\footnote{A
  discussion of template metaprogramming
  \citep{Vandevoorde+Josuttis:2003:Templates,Abrahams+Gurtovoy:2004:TemplateMetaprogramming} is beyond the
  scope of this article.}  to convert a wide and extensible set of types and
classes to the most appropriate type of \proglang{R} object. The signature of the
\code{wrap} template is as follows:
%
\begin{Code}
template <typename T> SEXP wrap(const T& object);
\end{Code}
%
The templated function takes a reference to a `wrappable'
object and converts this object into a \code{SEXP}, which is what \proglang{R} expects.
Currently wrappable types are:
\begin{itemize}
\item primitive types: \code{int}, \code{double}, \code{bool}, \dots which are converted
into the corresponding atomic \proglang{R} vectors;
\item \code{std::string} objects which are converted to \proglang{R} atomic character vectors;
\item Standard Template Library (STL) containers such as \code{std::vector<T>} or \code{std::map<T>},
as long as the template parameter type \code{T} is itself wrappable;
\item STL maps which use \code{std::string} for keys
({e.g.}, \code{std::map<std::string, T>}); as long as
the type \code{T} is wrappable;
\item any type that implements implicit conversion to \code{SEXP} through the
\code{operator SEXP()};
\item any type for which the \code{wrap} template is
fully specialized.
\end{itemize}

Wrappability of an object type is resolved at compile time using
modern techniques of template meta programming and class traits. The
\code{Rcpp-extending} vignette in the \pkg{Rcpp} package discusses in depth how to extend \code{wrap}
to third-party types. The \pkg{RcppArmadillo}
\citep*{CRAN:RcppArmadillo} and \pkg{RcppGSL} \citep{CRAN:RcppGSL} packages
feature several examples.
The following segment of code illustrates that the design allows
composition:

\begin{Code}
RcppExport SEXP someFunction() {
  std::vector<std::map<std::string,int> > v;
  std::map<std::string, int> m1;
  std::map<std::string, int> m2;

  m1["foo"]=1;
  m1["bar"]=2;
  m2["foo"]=1;
  m2["bar"]=2;
  m2["baz"]=3;

  v.push_back( m1 );
  v.push_back( m2 );
  return Rcpp::wrap( v );
}
\end{Code}
%
In this example, the STL types \verb+vector+ and \verb+map+ are used to
create a list of two named vectors. The member function \verb+push_back+
insert a given element into a vector.  This example is equivalent to the
result of this \proglang{R} statement:
%
\begin{Code}
list(c(bar = 2L, foo = 1L), c(bar = 2L, baz = 3L, foo = 1L))
\end{Code}


\subsection[R to C++: as]{\proglang{R} to \proglang{C++}: \code{as}}

The reverse conversion from an \proglang{R} object to a \proglang{C++} object is implemented by variations of the
\code{Rcpp::as} template whose signature is:
%
\begin{Code}
template <typename T> T as(SEXP x);
\end{Code}
%
It offers less flexibility and currently
handles conversion of \proglang{R} objects into primitive types ({e.g.}, \code{bool}, \code{int}, \code{std::string}, \dots),
STL vectors of primitive types  ({e.g.}, \code{std::vector<bool>},
\code{std::vector<double>}, \dots) and arbitrary types that offer
a constructor that takes a \code{SEXP}. In addition \code{as} can
be fully or partially specialized to manage conversion of \proglang{R} data
structures to third-party types as can be seen for example in the
\pkg{RcppArmadillo} package which eases transfer of \proglang{R} matrices and vectors to
the optimised data structures in the \pkg{Armadillo} linear algebra library \citep{Sanderson:2010:Armadillo}.


\subsection{Implicit use of converters}

The converters offered by \code{wrap} and \code{as} provide a very
useful framework to implement code logic in terms of \proglang{C++}
data structures and then explicitly convert data back to \proglang{R}.

In addition, the converters are also used implicitly
in various places in the \code{Rcpp} API.
Consider the following code that uses the \code{Rcpp::Environment} class to
interchange data between \proglang{C++} and \proglang{R}. It accesses a vector
\texttt{x} from the global environment, creates an STL \texttt{map} of string
types and pushes this back to \proglang{R}:
%
\begin{Code}
Rcpp::Environment global = Rcpp::Environment::global_env();
std::vector<double> vx = global["x"];

std::map<std::string, std::string> map;
map["foo"] = "oof";
map["bar"] = "rab";

global["y"] = map;
\end{Code}
%
In the first part of the example, the code extracts a
\code{std::vector<double>} from the global environment. In order to achieve this,
the \code{operator[]}  of \code{Environment} uses the proxy pattern
\citep{Meyers:1995:MoreEffectiveC++}
to distinguish between left hand side (LHS) and right hand side (RHS) use.

The output of the \code{operator[]} is an instance of the nested class
\code{Environment::Binding}. This class defines a templated implicit conversion
operator. It is this conversion operator which allows a \code{Binding}
object to be assigned to any type that \code{Rcpp::as} is able to handle.

In the last part of the example, the LHS use of the \code{Binding} instance is
implemented through its assignment operator. This is also templated and uses
\code{Rcpp::wrap} to perform the conversion to a \code{SEXP} that can be
assigned to the requested symbol in the global environment.

The same mechanism is used throughout the API. Examples include access/modification
of object attributes, slots, elements of generic vectors (lists),
function arguments, nodes of dotted pair lists, language calls and more.

\section{Application II}
\label{sec:functions}

\begin{table}[t!]
  \begin{minipage}[t]{0.465\linewidth}
    \centering{\underline{Environment: Using the \pkg{Rcpp} API}}
    \begin{Code}
Environment stats("package:stats");
Function rnorm = stats["rnorm"];
return rnorm(10,
             Named("sd", 100.0));
    \end{Code}
\end{minipage}
  \begin{minipage}{0.06\linewidth}
    \phantom{XXX}
  \end{minipage}
  \begin{minipage}[t]{0.465\linewidth}
    \centering{\underline{Environment: Using the \proglang{R} API}}
    \begin{Code}
SEXP stats = PROTECT(
  R_FindNamespace(
    mkString("stats")));
SEXP rnorm = PROTECT(
  findVarInFrame(stats,
               install("rnorm")));
SEXP call  = PROTECT(
  LCONS( rnorm,
    CONS(ScalarInteger(10),
      CONS(ScalarReal(100.0),
           R_NilValue))));
SET_TAG(CDDR(call),install("sd"));
SEXP res = PROTECT(eval(call,
                   R_GlobalEnv));
UNPROTECT(4);
return res;
    \end{Code}
  \end{minipage}

\bigskip

  \begin{minipage}[t]{0.465\linewidth}
    \centering{\underline{Language: Using the \pkg{Rcpp} API}}
    \begin{Code}
Language call("rnorm", 10,
              Named("sd",100.0));
return call.eval();
    \end{Code}
  \end{minipage}
  \begin{minipage}{0.06\linewidth}
    \phantom{XXX}
  \end{minipage}
  \begin{minipage}[t]{0.465\linewidth}
    \centering{\underline{Language: Using the \proglang{R} API}}
    \begin{Code}
SEXP call  = PROTECT(
    LCONS(install("rnorm"),
    CONS(ScalarInteger(10),
      CONS(ScalarReal(100.0),
           R_NilValue))));
SET_TAG(CDDR(call),install("sd"));
SEXP res = PROTECT(eval(call,
                   R_GlobalEnv));
UNPROTECT(2);
return res;
    \end{Code}
  \end{minipage}

\bigskip

  \begin{minipage}[t]{0.465\linewidth}
    \centering{\underline{Sugar: Using the \pkg{Rcpp} API}}
    \begin{Code}
RNGScope scope;
return rnorm(10, 0, 100);
    \end{Code}
\end{minipage}
  \begin{minipage}{0.06\linewidth}
    \phantom{XXX}
  \end{minipage}
  \begin{minipage}[t]{0.465\linewidth}
    \centering{\underline{Sugar: Using the \proglang{R} API}}

    \medskip
    (not applicable)
  \end{minipage}

\bigskip

  \caption{\pkg{Rcpp} versus the \proglang{R} API: Five ways of calling
    \code{rnorm(10L, sd = 100)} in \proglang{C}/\proglang{C++}.}
  \label{fig:rnormCode}
  \medskip \small
  Note that we have removed the \code{Rcpp::} prefix for readability; this corresponds to adding a directive
  \texttt{using namespace Rcpp;} in the code. The versions that use callbacks to \proglang{R} do not require handling
  of the state of the random number generator. The version that uses \pkg{Rcpp} sugar requires it, which
  is done via the instantiation of the \code{RNGScope} variable.
\end{table}

The next example shows how to use \pkg{Rcpp} to emulate the \proglang{R} code
\code{rnorm(10L, sd = 100.0)}.
As shown in Table~\ref{fig:rnormCode}, the code can be expressed in several
ways in either \pkg{Rcpp} or the standard \proglang{R} API. The first version shows the
use of the \code{Environment} and \code{Function} classes by
\pkg{Rcpp}.
The second version shows the use of the \code{Language} class, which
manages calls (LANGSXP).
For comparison, we also show both versions using the standard \proglang{R} API.
Finally, we also show a variant using `\pkg{Rcpp} sugar', a topic which is
discussed in Sections~\ref{sec:perfcomp} and \ref{sec:ongoing} below.

This example illustrates that the \pkg{Rcpp} API permits us to work with code
that is easier to read, write and maintain. More examples are available as
part of the documentation included in the \pkg{Rcpp} package, as well as
among its over seven hundred and fifty unit tests.

\section{Application III}
\label{sec:inline}

Extending \proglang{R} with compiled code requires a mechanism for reliably compiling,
linking, and loading the code. While using a package is preferable in the long run,
it may be too involved for quick explorations. An alternative is
provided by the \pkg{inline} package \citep{CRAN:inline} which compiles,
links and loads a \proglang{C}, \proglang{C++} or \proglang{Fortran} function---directly from the \proglang{R} prompt
using simple functions \code{cfunction} and \code{cxxfunction}.  The latter provides an extension which
works particularly well with \pkg{Rcpp} via so-called `plugins' which provide
information about additional header file and
library locations.

The use of \pkg{inline} is possible as \pkg{Rcpp} can be installed and
updated just like any other \proglang{R} package using, for examples, the
\code{install.packages()} function for initial installation as well as
\code{update.packages()} for upgrades.  So even though \proglang{R}/\proglang{C++} interfacing
would otherwise require source code, the \pkg{Rcpp} library is always provided
ready for use as a pre-built library through the CRAN package
mechanism.\footnote{This presumes a platform for which pre-built binaries are
  provided. \pkg{Rcpp} is available in binary form for Windows and OS~X users from
  CRAN, and as a \code{.deb} package for Debian and Ubuntu users. For other systems, the
  \pkg{Rcpp} library is automatically built from source during installation
  or upgrades.}

The library and header files provided by \pkg{Rcpp} for use by other packages
are installed along with the \pkg{Rcpp} package. The \code{LinkingTo:}~\code{Rcpp}
directive in the \code{DESCRIPTION} file lets \proglang{R} properly reference the header files.
The \pkg{Rcpp} package provides appropriate information for the \code{-L}
switch needed for linking via the function \code{Rcpp:::LdFlags()}.
It can be used by \code{Makevars} files of other
packages, and \pkg{inline} makes use of it internally so that all of this is
done behind the scenes without the need for explicitly setting compiler or
linker options.

The convolution example provided above can be rewritten for use by
\pkg{inline} as shown below.  The function body is provided by the \proglang{R} character
variable \code{src}, the function header is defined by the argument
\code{signature}, and we only need to enable \code{plugin = "Rcpp"} to obtain a
new \proglang{R} function \code{fun} based on the \proglang{C++} code in \code{src}:
%
\begin{CodeChunk}
\begin{CodeInput}
R> src <- '
+   Rcpp::NumericVector xa(a);
+   Rcpp::NumericVector xb(b);
+   int n_xa = xa.size(), n_xb = xb.size();
+
+   Rcpp::NumericVector xab(n_xa + n_xb - 1);
+   for (int i = 0; i < n_xa; i++)
+     for (int j = 0; j < n_xb; j++)
+        xab[i + j] += xa[i] * xb[j];
+   return xab;
+ '
R> fun <- cxxfunction(signature(a = "numeric", b = "numeric"),
+    src, plugin = "Rcpp")
R> fun(1:3, 1:4)
\end{CodeInput}
\begin{CodeOutput}
[1]  1  4 10 16 17 12
\end{CodeOutput}
\end{CodeChunk}
%
With one assignment to the \proglang{R} variable \code{src}, and one call of the \proglang{R} function
\code{cxxfunction} (provided by the \pkg{inline} package), we have created a new \proglang{R}
function \code{fun} that uses the \proglang{C++} code we assigned to
\code{src}---and all this functionality can be used directly from the \proglang{R}
prompt making prototyping with \proglang{C++} functions straightforward.

\textsl{Update}: \pkg{Rcpp} version 0.10.0 and later contain new and powerful feature
called 'Rcpp Attributes' which provides an even more powerful mechanism; see
\cite{CRAN:Rcpp:Attributes} for more details.


\section{Performance comparison}
\label{sec:perfcomp}

In this section, we present several different ways to leverage \pkg{Rcpp} to
rewrite the convolution example from `Writing \proglang{R} Extensions' \citep[Chapter 5]{R:Extensions}
first discussed in Section~\ref{sec:new_rcpp}.
As part of the redesign of \pkg{Rcpp}, data copy is kept to the
absolute minimum: The \code{RObject} class and all its derived
classes are just a container for a \code{SEXP} object. We let \proglang{R} perform
all memory management and access data though the macros or functions
offered by the standard \proglang{R} API.

The implementation of the \code{operator[]} is designed to be as
efficient as possible, using both inlining and caching,
but even this implementation is still less efficient than the
reference \proglang{C} implementation described in \cite{R:Extensions}.

\pkg{Rcpp} follows design principles from the STL, and classes such
as \code{NumericVector} expose iterators that can be used for
sequential scans of the data. Algorithms using iterators are
usually more efficient than those that operate on objects using the
\code{operator[]}. The following version of the convolution function
illustrates the use of the \code{NumericVector::iterator}.
%
\begin{Code}
#include <Rcpp.h>

RcppExport SEXP convolve4cpp(SEXP a, SEXP b) {
    Rcpp::NumericVector xa(a), xb(b);
    int n_xa = xa.size(), n_xb = xb.size();
    Rcpp::NumericVector xab(n_xa + n_xb - 1);

    typedef Rcpp::NumericVector::iterator vec_iterator;
    vec_iterator ia = xa.begin(), ib = xb.begin();
    vec_iterator iab = xab.begin();
    for (int i = 0; i < n_xa; i++)
        for (int j = 0; j < n_xb; j++)
            iab[i + j] += ia[i] * ib[j];

    return xab;
}
\end{Code}
%
One of the focuses of recent developments of \pkg{Rcpp} is called `\pkg{Rcpp} sugar',
and aims to provide R-like syntax in \proglang{C++}. While a fuller discussion of \pkg{Rcpp} sugar is
beyond the scope of this article, we have included
another version of the convolution algorithm based on \pkg{Rcpp} sugar for illustrative purposes here:
%
\begin{Code}
#include <Rcpp.h>

RcppExport SEXP convolve11cpp(SEXP a, SEXP b) {
    Rcpp::NumericVector xa(a), xb(b);
    int n_xa = xa.size(), n_xb = xb.size();
    Rcpp::NumericVector xab(n_xa + n_xb-1, 0.0);

    Rcpp::Range r( 0, n_xb-1 );
    for (int i=0; i<n_xa; i++, r++)
        xab[ r ] += Rcpp::noNA(xa[i]) * Rcpp::noNA(xb);
    return xab ;
}
\end{Code}
%
\pkg{Rcpp} sugar allows manipulation of entire subsets of vectors at once, thanks to
the \code{Range} class. \pkg{Rcpp} sugar uses techniques such as expression templates,
lazy evaluation and loop unrolling to generate very efficient code.
The \code{noNA} template function marks its argument to indicates that it does
not contain any missing values---an assumption made implicitly by other
versions---allowing sugar to compute the individual operations without having
to test for missing values.

We have benchmarked the various implementations by averaging over 5000 calls
of each function with \code{a} and \code{b} containing 200 elements
each.\footnote{The code is contained in the directory
  \code{inst/examples/ConvolveBenchmarks} in the \pkg{Rcpp} package.} The timings
are summarized in Table~\ref{tab:benchmark} below.

\begin{table}[t]
  \begin{center}
    \begin{small}
      \begin{tabular}{lrr}
        \toprule
        Implementation                    & Time in millisec. & Relative to \proglang{R} API \\
        \cmidrule(r){2-3}
        \proglang{R} API (as benchmark)             &  218       & \\
        \pkg{Rcpp} sugar                        &  145       & 0.67 \\
        \code{NumericVector::iterator}    &  217       & 1.00 \\
        \code{NumericVector::operator[]}  &  282       & 1.29 \\
        %\code{RcppVector<double>}         &  683       & 3.13 \\
        \bottomrule
      \end{tabular}
    \end{small}
    \caption{Run-time performance of the different convolution examples.}
    \label{tab:benchmark}
  \end{center}
\end{table}

The first implementation, written in \proglang{C} and using the traditional \proglang{R} API,
provides our base case. It takes advantage of pointer arithmetics and therefore
does not to pay the price of \proglang{C++} object encapsulation or operator overloading.

The slowest solution illustrates the price of object encapsulation. Calling an overloaded
\code{operator[]} as opposed to using direct pointer arithmetics as in the
reference case costs about 29\% in performance.

The next implementation uses iterators rather than indexing. Its performance
is indistinguishable from the base case.
This also shows that the use of \proglang{C++} may not necessarily imply any performance
penalty. Further, \proglang{C++} \code{iterators} can be used to achieve the performance
of \proglang{C} pointers, but without the potential dangers of direct memory
access via pointers.

Finally, the fastest implementation uses \pkg{Rcpp} sugar. It performs
significantly better than the base case.  Explicit loop unrolling provides us with
vectorization at the \proglang{C++} level which is responsible for this particular speedup.

\section{On-going development}
\label{sec:ongoing}

\pkg{Rcpp} is in very active development: Current work in the
package (and in packages such as \pkg{RcppArmadillo})
focuses on further improving interoperability between \proglang{R} and \proglang{C++}.
Two core themes for on-going development are `\pkg{Rcpp} sugar' as well as `\pkg{Rcpp} modules', both of which are
also discussed in more detail in specific vignettes in the \pkg{Rcpp} package.

`\pkg{Rcpp} sugar' offers syntactic
sugar at the \proglang{C++} level, including optimized binary operators and many
\proglang{R} functions such as \code{ifelse}, \code{sapply}, \code{any}, \code{head},
\code{tail}, and more.
The main technique used in \pkg{Rcpp} sugar is
expression templates pioneered by the \pkg{Blitz++} library \citep{Veldhuizen:1998:Blitz}
and since adopted
by projects such as \pkg{Armadillo} \citep{Sanderson:2010:Armadillo}.
Access to most of the d/p/q/r-variants of the statistical distribution
functions has also been added, enabling the use of expressions such as
\code{dnorm(X, m, s)} for a numeric vector \code{X} and scalars \code{m} and
\code{s}. This was shown in Table~\ref{fig:rnormCode} in
Section~\ref{sec:functions} above where
the \proglang{R} expression \code{rnorm(10L, sd = 100)}
was rewritten in \proglang{C++} as \code{rnorm(10, 0, 100)}. Note that
\proglang{C++} semantics require the second parameter to be used here, which is
different from the \proglang{R} case.

`\pkg{Rcpp} modules' allows programmers to expose \proglang{C++} functions and classes at the
\proglang{R} level. This offers access to \proglang{C++} code from \proglang{R} using even less interface
code than by writing accessor functions. Modules are inspired by the
\pkg{Boost.Python} library
\citep{Abrahams+Grosse-Kunstleve:2003:Boost.Python} which provides similar
functionality for \proglang{Python}. \proglang{C++} classes exposed by \pkg{Rcpp} modules are
shadowed by reference classes which have been introduced in \proglang{R} 2.12.0.

\textsl{Update}: Besides the vignettes for '\pkg{Rcpp} Sugar'
\citep{CRAN:Rcpp:Sugar} and '\pkg{Rcpp} Modules' \citep{CRAN:Rcpp:Modules},
the aforementioned vignette for '\pkg{Rcpp} Attributes'
\citep{CRAN:Rcpp:Attributes} describes a new possibility for even more direct
integration between \proglang{Rcpp} and \proglang{C++}.

\section{Summary}

The \pkg{Rcpp} package presented in this paper greatly simplifies integration of
compiled \proglang{C++} code with \proglang{R}.
\pkg{Rcpp} provides a \proglang{C++} class hierarchy which allows manipulation of \proglang{R} data structures in \proglang{C++}
using member functions and operators directly related to the type
of object being used, thereby reducing the level of expertise
required to master the various functions and macros offered by the
internal \proglang{R} API. The classes assume the entire
responsibility of garbage collection of objects, relieving the
programmer from book-keeping operations with the protection stack
and enabling him/her to focus on the underlying problem.

Data interchange between \proglang{R} and \proglang{C++} code is performed by the \code{wrap()} and
\code{as()} template functions. They allow the programmer to write logic in terms
of \proglang{C++} data structures, and facilitate use of modern libraries such as the
Standard Template Library (STL) and its containers and algorithms. The
\code{wrap()} and \code{as()} template functions are extensible by
design. They are also used either explicitly or implicitly throughout the API.
By using only thin wrappers around \code{SEXP} objects and adopting \proglang{C++}
idioms such as iterators, the footprint of the \pkg{Rcpp} API
is very lightweight, and does not incur a significant performance penalty.

The \pkg{Rcpp} API offers opportunities to dramatically reduce the complexity
of code, which should lower the initial cost of writing code and improve code readability, maintainability, and
reuse---without incurring noticeable penalties in run-time performance.

\section*{Acknowledgments}

Detailed comments and suggestions by editors as well as anonymous referees
are gratefully acknowledged.  We are also thankful for code contributions by
Douglas Bates and John Chambers, as well as for very helpful suggestions by Uwe
Ligges, Brian Ripley and Simon Urbanek concerning the build systems for different
platforms.   Last but not least, several users provided very fruitful
ideas for new or extended features via the \code{rcpp-devel} mailing list.

\bibliography{\Sexpr{Rcpp:::bib()}}

\vspace*{-0.35cm}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:

