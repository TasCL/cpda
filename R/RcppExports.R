# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Switch Model's Prior Distributions
#'
#' This Rcpp function computes the prior for the given parameter set. The
#' prior for each parameter here is just a uniform distribution for
#' simplicity.
#'
#' @param pVec a parameter vector. Similar to DMC's p.vector
#' @return a prior probability density summed across parameters
#' @import Rcpp
#' @export
#' @examples
#' p.vector <- c(1.51, 3.32, 1.51, 2.24, 3.69, 0.31, 0.08)
#' SwitchModelPrior(pVec=p.vector)
#' require(rbenchmark)
#' within(benchmark(R=SwitchModel_Prior(p.vector),
#'                  Cpp=SwitchModelPrior(p.vector),
#'                  replications=rep(1e4, 3),
#'                  columns=c('test', 'replications', 'elapsed'),
#'                  order=c('test', 'replications')),
#'                  { average = elapsed/replications })
#' #   test replications elapsed  average
#' # 2  Cpp        10000   0.048 4.80e-06
#' # 4  Cpp        10000   0.032 3.20e-06
#' # 6  Cpp        10000   0.056 5.60e-06
#' # 1    R        10000   0.151 1.51e-05
#' # 3    R        10000   0.182 1.82e-05
#' # 5    R        10000   0.142 1.42e-05
SwitchModelPrior <- function(pVec) {
    .Call('pda_SwitchModelPrior', PACKAGE = 'pda', pVec)
}

#' Initialize a DMC Sample
#'
#' This functions initializes the initial conditions and various data structures
#' for the MCMC, using C++
#'
#' @param nmc number of MCMC iteration (steps).
#' @param npar number of parameter.
#' @param nchain number of chains
#' @keywords initialize_structures
#' @return a list with 7 elements: param_old, param_chain, proposal, direction,
#' LL_keep, nmc, and nchain
#' @import Rcpp
#' @export
#' @examples
#' initializeStructures(nmc=20, npar=7, nchain=3)
initializeStructures <- function(nmc, npar, nchain) {
    .Call('pda_initializeStructures', PACKAGE = 'pda', nmc, npar, nchain)
}

#' Retrieve Empirical and Modelled Decision Times
#'
#' Get decision times for two-accumulator LBA model
#'
#' @param data a Rcpp List for subject data
#' @param pVec a Rcpp NumvericVector for parameter vector
#' @param MCMC_params MCMC parameters
#' @return A four-element list with estimated decision time for accumulator 1,
#' accumultor 2, empirical decision time for accumualtor 1 and accumulator 2.
#' @examples
#' load("data/Data1.rda")
#' p.vector <- c(1.51, 3.32, 1.51, 2.24, 3.69, 0.31, 0.08)
#' mcmcParams <- list(sigma_exact=1, bandwidth=.02, LL_NSAMPLE=1e2,
#'                     Nstep=30, Nchain=24, noise_size=.001, burnin=10,
#'                     resample_mod=3)
#'
#' DTs <- getDTs(d, p.vector, mcmcParams)
#' str(DTs)
#' @export
getDTs <- function(data, pVec, MCMC_params) {
    .Call('pda_getDTs', PACKAGE = 'pda', data, pVec, MCMC_params)
}

#' Compute Log-likelihood Using Fast Fourier Transform
#'
#' This function implements Holmes's (2015) KDE-FFT method to calculate
#' approximate probability density.
#'
#' @param DT a vector of empirical decision times
#' @param eDT a vector of modelled decision times
#' @param m min value
#' @param M max value
#' @param h KDE bandwidth
#' @param ns number of binned samples
#' @return Log-likelihood
#' @references Holmes, W. (2015). A practical guide to the Probability Density
#' Approximation (PDA) with improved implementation and error characterization.
#' \emph{Journal of Mathematical Psychology}, \bold{68-69}, 13--24,
#' doi: http://dx.doi.org/10.1016/j.jmp.2015.08.006.
#' @export
#' @examples
#' DT1 <- read.csv("data/DT1.csv", header=F)
#' DT2 <- read.csv("data/DT2.csv", header=F)
#' eDT1 <- read.csv("data/eDT1.csv", header=F)
#' eDT2 <- read.csv("data/eDT2.csv", header=F)
#' bandwidth <- .02;
#' nsample <- 1e4
#' m <- min(c(DT1$V1, DT2$V1)) - 3 * bandwidth
#' M <- max(c(DT1$V1, DT2$V1)) + 3 * bandwidth
#' logLik_fft(DT1$V1, eDT1$V1, m, M, bandwidth, nsample)
#' logLik_fft(DT2$V1, eDT2$V1, m, M, bandwidth, nsample)
logLik_fft <- function(DT, eDT, m, M, h, ns) {
    .Call('pda_logLik_fft', PACKAGE = 'pda', DT, eDT, m, M, h, ns)
}

#' Compute FFT Log-likelihood for Piece-wise LBA Model
#'
#' Use logLik_fft to get probability density for a piecewise LBA model.
#'
#' @param data subject data
#' @param pVec a parameter vector for piece-wise LBA Model
#' @param MCMC_params MCMC parameters
#' @return Log-likelihood
#' @export
#' @examples
#' mcmcParams <- list(sigma_exact=1, bandwidth=.02, LL_NSAMPLE=1e4,
#'                   Nstep=30, Nchain=24, noise_size=.001, burnin=10,
#'                   resample_mod=3)
#'
#' load("data/Data1.rda")
#' dplyr::tbl_dt(d)
#'
#' ## Source: local data table [1,000 x 3]
#' ##      Response ResponseTime Block
#' ##         (dbl)        (dbl) (dbl)
#' ##   1         0    0.5676343     1
#' ##   2         1    0.6183177     1
#' ##   3         0    0.8806298     1
#' ##   4         0    0.4563023     1
#' ##   5         1    0.8496136     1
#' ##   6         0    0.5866219     1
#' ##   7         1    0.6482302     1
#' ##   8         1    0.3510035     1
#' ##   9         0    0.6117150     1
#' ##   10        0    0.6940521     1
#' ##   ..      ...          ...   ...
#'
#' pVec <- c(1.51, 3.32, 1.51, 2.24, 3.69, 0.31, 0.08)
#' tmp0 <- logLik_pLBA(data=d, pVec=pVec, MCMC_params=MCMC_params)
#' @export
logLik_pLBA <- function(data, pVec, MCMC_params) {
    .Call('pda_logLik_pLBA', PACKAGE = 'pda', data, pVec, MCMC_params)
}

