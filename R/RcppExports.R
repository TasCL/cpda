# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Generate a Gamma Vector 
#'
#' This is part of DEMC algorithm. \code{gammaVec} generates a gamma vector to 
#' facilitate vector-based element-wise compuation at C++.
#' 
#' @param n number of parameters. 
#' @param gamma a tuning parameter for gamma mutation. Usually set at 2.38  
#' @return a column vector
#' @examples
#' pVec <- c(A=1.51, b=2.7, muv1=3.32, muv2=2.24, t_ND=0.08, muw1=1.51,  
#'           muw2=3.69, t_delay=0.31,  sv=1, swt=0.5)
#' gamma <- gammaVec(length(pVec), 2.38)
#' @export
gammaVec <- function(n, gamma) {
    .Call('cpda_gammaVec', PACKAGE = 'cpda', n, gamma)
}

#' Pick Two Other Chains Randomly
#'
#' This is part of DEMC algorithm. The function picks three other chains (0, 
#' 1, 2), except the currently processed one (k).
#'
#' @param k an integer indicating which chain is currently running. This has
#' to be an integer and with the range of 0 to nchain-1. There is no check to
#' preventing the function from crashing, if the user enter an irregular
#' number.
#' @param n number of picked chains.
#' @param chains a vector of chain index, e.g., 0:24.  
#' @return a column vector
#' @keywords pickchains
#' @examples
#' nchain <- 24
#' chainSeq <- (1:24)-1 ## Use C++ index
#' pickchains(3, 2, chainSeq)
#' 
#' @export
pickchains <- function(k, n, chains) {
    .Call('cpda_pickchains', PACKAGE = 'cpda', k, n, chains)
}

#' DEMC Algorithm  
#'
#' This is part of DEMC algorithm. This function uses crossover sampler to 
#' proposal a new parameter vector. 
#' 
#' @param useTheta a npar x nchain matrix 
#' @param gamma a gamma vector. 
#' @param k current chain index. Note chain index starts from 0.
#' @param rp ter Braak's (2006) b, setting the range of the uniform 
#' distribution that derived epsilon. This is usually set 0.001 or suggested 
#' by ter Braak (ROT) 1e-4.   
#' @return a column vector
#' @keywords a matrix
#' @examples
#' pVec <- c(A=1.51, b=2.7, muv1=3.32, muv2=2.24, t_ND=0.08, muw1=1.51,  
#'           muw2=3.69, t_delay=0.31, sv=1, swt=0.5)
#' setting  <- c(bandwidth=.02, ns=1e4, nmc=6, nchain=24, rp=.001, burnin=10,
#'               nthin=3, start=1, gammaMult=2.38, report=20)
#' samples  <- init(pVec, setting)
#' useTheta <- samples$theta[,,1]
#' dim(useTheta)  ## 10 x 24; npar x nchain
#' 
#' gamma <- gammaVec(length(pVec), setting[9])
#' 
#' ## Current chain index is 0 (C-based index)
#' crossover(useTheta, gamma, 0, 1e-4)
#' 
#' @export
crossover <- function(useTheta, gamma, k, rp) {
    .Call('cpda_crossover', PACKAGE = 'cpda', useTheta, gamma, k, rp)
}

#' Initialise a pLBA Bayeisan Sample
#'
#' This functions initialises a pLBA sample 
#'
#' @param pVec a vector storing pLBA model parameters. The sequence is 
#' critical. It is, A, b, muv1, muv2, t_ND, muw1, muw2, t_delay, sv, swt. 
#' @param setting DE and MC setting, including, nmc, nchain, etc.
#' @keywords initialize_structures
#' @return a list with 7 elements: param_old, param_chain, proposal, direction,
#' LL_keep, nmc, and nchain
#' @export
#' @examples
#' pVec <- c(A=1.51, b=2.7, muv1=3.32, muv2=2.24, t_ND=0.08, muw1=1.51,  
#'           muw2=3.69, t_delay=0.31,  sv=1, swt=0.5)
#' 
#' ## Setting sequence is critical, too! 
#' setting <- c(bandwidth=.02, ns=1e5, nmc=30, nchain=24, rp=.001, burnin=10,
#' nthin=3, start=1, gammaMult=2.38, report=100)
#' tmp0 <- init(pVec, setting)
#' str(tmp0)
#' ## List of 5
#' ## $ opVec    : num [1:10, 1:24] -1.749 3.207 2.432 4.913 0.391 ...
#' ## $ theta    : num [1:10, 1:24, 1:30] -1.749 3.207 2.432 4.913 0.391 ...
#' ## $ prospoal : num [1:10, 1:24] NA NA NA NA NA NA NA NA NA NA ...
#' ## $ direction: num [1:10, 1:24] NA NA NA NA NA NA NA NA NA NA ...
#' ## $ LL_keep  : num [1:30, 1:24] NA NA NA NA NA NA NA NA NA NA ...
#' 
init <- function(pVec, setting) {
    .Call('cpda_init', PACKAGE = 'cpda', pVec, setting)
}

#' Compute FFT Log-likelihood for a Gaussian Distribution
#'
#' This is a wrapper function to approximate a Gaussian distribution, using
#' KDE-FFT method. To retrieve more outputs and replicate Holmes's example 1,
#' please use \code{logLik_norm2}.
#'
#' @param object a vector storing empirical data
#' @param pVec parameter vector storing mean and standard deviation
#' @param ns number of simulations. 
#' @return Log-likelihood; plus PDF, grid centers, and PDF_hist
#' @export
#' @examples
#' pVec <- c(mu=5, sigma=1)
#' y    <- sort(rnorm(1e5, pVec[1], pVec[2]))
#'
#' ll1 <- logLik_norm(y, pVec, 1e5)
#' ll2 <- logLik_norm2(y, pVec, 1e5)
#' str(ll1); str(ll2)
#'
#' plot(ll2$z, ll2$PDF_hist, type="l", lty=2,
#' main="Normal Distribution",xlab="x",ylab="L(x|beta)")
#' lines(y, ll2$PDF, col="red", lwd = 1.5)
#'
logLik_norm <- function(object, pVec, ns) {
    .Call('cpda_logLik_norm', PACKAGE = 'cpda', object, pVec, ns)
}

#' @rdname logLik_norm
#' @export
logLik_norm2 <- function(object, pVec, ns) {
    .Call('cpda_logLik_norm2', PACKAGE = 'cpda', object, pVec, ns)
}

#' Compute FFT Log-likelihood for a pLBA Model
#'
#' This is a wrapper function to approximate a pLBA distribution, using
#' KDE-FFT method. To retrieve more outputs, please use \code{logLik_pLBA2}.
#'
#' @param object a matrix storing empirical choice RT data. First column must
#' stores choices and second column stores RTs in seconds.
#' @param pVec a vector storing pLBA model parameters. The sequence is 
#' critical. It is, A, b, muv1, muv2, t_ND, muw1, muw2, t_delay, sv, swt. 
#' @param ns number of simulations. Usually \code{cpda} can handle up to 1e6. 
#' Use \code{gpda} if large simulation is required.
#' @return a summed, logged likelihood across trials and accumulators.
#' @export
#' @examples  
#' rm(list=ls())
#' data(lba)
#' dMat <- data.matrix(d)
#' head(dMat)
#' 
#' pVec <- c(A=1.51, b=2.7, muv1=3.32, muv2=2.24, t_ND=0.08, muw1=1.51, muw2=3.69,
#'           t_delay=0.31, sv=1, swt=0.5)
#' ## setting <- c(bandwidth=.02, ns=1e5, nmc=30, nchain=24, rp=.001, burnin=10,
#' ## nthin=3, start=1, gammaMult=2.38, report=100)
#' tmp0 <- cpda::logLik_plba(dMat, pVec, 1e5); tmp0
#'  
logLik_plba <- function(object, pVec, ns) {
    .Call('cpda_logLik_plba', PACKAGE = 'cpda', object, pVec, ns)
}

#' Compute FFT Log-likelihood for a LBA Model
#'
#' This is a wrapper function to approximate a LBA distribution, using
#' KDE-FFT method. To retrieve more outputs, please use \code{logLik_LBA2}.
#'
#' @param object a matrix storing empirical choice RT data. First column must
#' stores choices and second column stores RTs in seconds.
#' @param pVec pLBA parameter vector. The sequence is 
#' critical. It is, b1, b2, A1, A2, mu1, mu2, sigma1, sigma2, t01, and t02. 
#' @param ns number of simulations. Usually \code{cpda} can handle up to 1e6. 
#' Use \code{gpda} if large simulation is required.
#' @return a summed, logged likelihood across trials and accumulators.
#' @export
#' @examples  
#' rm(list=ls())
#' data(lba)
#' dMat <- data.matrix(d)
#' head(dMat)
#'  
#' pVec <- c(b1=1, b2=1, A1=.5, A2=.5, mu1=2.4, mu2=1.6, sigma1=1, sigma2=1.2,
#' t01=.5, t02=.5)
#' tmp0 <- cpda::logLik_lba(dMat, pVec, 1e5); tmp0
#'  
logLik_lba <- function(object, pVec, ns) {
    .Call('cpda_logLik_lba', PACKAGE = 'cpda', object, pVec, ns)
}

#' Generate Random Choice Response Times Using LBA Model
#'
#' This function uses two-accumulator LBA model to generate random choice RTs.
#' 
#' \itemize{
#' \item \bold{\emph{b1}} response threshold for accumulator 1. 
#' \item \bold{\emph{b2}} response threshold for accumulator 2. 
#' \item \bold{\emph{A1}} starting point interval for accumulator 1. 
#' \item \bold{\emph{A2}} starting point interval for accumulator 2. 
#' \item \bold{\emph{mu1}} drift rate for accumulator 1.
#' \item \bold{\emph{mu2}} drift rate for accumulator 2. 
#' \item \bold{\emph{sigma1}} drift rate standard deviation for accumulator 1.
#' \item \bold{\emph{sigma2}} drift rate standard deviation for accumulator 2.
#' \item \bold{\emph{t01}} non-decision time for accumulator 1. 
#' \item \bold{\emph{t02}} non-decision time for accumulator 2. 
#' }
#'
#' @param n number of observations. Must be an integer
#' @param pVec a two-accumulator LBA parameter vector. The sequence is 
#' critical. It is, b1, b2, A1, A2, mu1, mu2, sigma1, sigma2, t01, and t02.
#' @return A matrix. First column stores choices and second column stores RTs 
#' in seconds
#' @export
#' @examples
#' n    <- 10
#' pVec <- c(b1=1, b2=1, A1=.5, A2=.5, mu1=2.4, mu2=1.6, sigma1=1, sigma2=1.2,
#'           t01=.5, t02=.5)
#' dat1 <- cpda::rlba(n, pVec)
#' str(dat1)
#' summary(dat1)
#' 
#' ## Compare to rtdists
#' ## dat2 <- rtdists::rLBA(n, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), 
#' ## sd_v=c(1,1.2))
#' ## str(dat2)
#' ## summary(dat2)
#' 
rlba <- function(n, pVec) {
    .Call('cpda_rlba', PACKAGE = 'cpda', n, pVec)
}

#' Generate Random Choice Decision Times
#'
#' Uses two-accumulator pLBA model to generate random choice DTs (not RTs!).
#' 
#' \itemize{
#' \item \bold{\emph{A}} starting point interval. A starting point is with the 
#' interval \code{[0, A]}. Average amount of prior evidence (ie before accumulation 
#' process even begins) across trials is \code{A/2}. 
#' \item \bold{\emph{b}} response threshold. \code{b-A/2} is a measure of 
#' \emph{response caution}.
#' \item \bold{\emph{muv1}} accumulator 1 drift rate, piece 1
#' \item \bold{\emph{muv2}} accumulator 2 drift rate, piece 1
#' \item \bold{\emph{t_ND}} non-decision time in second. 
#' \item \bold{\emph{muw1}} accumulator 1 drift rate, piece 2
#' \item \bold{\emph{muw2}} accumulator 2 drift rate, piece 2
#' \item \bold{\emph{t_delay}} delay time for the two-piece process   
#' \item \bold{\emph{sv}} a common standard deviation for all drift rates 
#' (muv1, muw1, muv2, muw2).
#' \item \bold{\emph{swt}} switch time, usually determined by experimental 
#' design).
#' }
#'
#' @param n number of observations. Must be an integer 
#' @param pVec a double vector storing pLBA model parameters. The sequence is 
#' critical. It is, A, b, muv1, muv2, t_ND, muw1, muw2, t_delay, sv, swt. 
#' @return A two-element list with estimated decision time for accumulator 1,
#' accumultor 2, empirical decision time for accumualtor 1 and accumulator 2.
#' @export
#' @examples
#' pVec <- c(A=1.51, b=2.7, muv1=3.32, muv2=2.24, t_ND=0.08, muw1=1.51, 
#'           muw2=3.69, t_delay=0.31, sv=1, swt=0.5)
#' ## setting <- c(bandwidth=.02, ns=1e5, nmc=30, nchain=24, rp=.001, burnin=10,
#' ## nthin=3, start=1, gammaMult=2.38, report=100)
#' DTs <- cpda::rplba(n=1e4, pVec)
#' summary(DTs)
#' head(DTs)
#' 
rplba <- function(n, pVec) {
    .Call('cpda_rplba', PACKAGE = 'cpda', n, pVec)
}

#' Retrieve Empirical Decision Times
#' 
#' This function takes pLBA parameters and converts choice RTs, stored in a 
#' matrix to choice DTs, stored in a list with two numeric vectors. 
#'  
#' @param data a double matrix with the first column stores choice (0==error; 
#' 1==correct), and the second column stores RTs in second.
#' @param pVec a double vector storing pLBA model parameters. The sequence is 
#' critical. It is, A, b, muv1, muv2, t_ND, muw1, muw2, t_delay, sv, swt. 
#' @return A two-element list with decision time for accumulator 1 and 2.
#' @export
#' @examples
#' data(lba)
#' pVec <- c(A=1.51, b=2.7, muv1=3.32, muv2=2.24, t_ND=0.08, muw1=1.51,  
#'           muw2=3.69, t_delay=0.31,  sv=1, swt=0.5)
#'            
#' DTs <- cpda::choiceDT(data.matrix(d), pVec)
#' 
#' ## Wrong sequence
#' pVecWrong <- c(A=1.51, muv1=3.32, muw1=1.51, muv2=2.24, muw2=3.69,
#'               t_delay=0.31, t_ND=0.08, b=2.7, sv=1, swt=0.5)
#' DTX <- cpda::choiceDT(data.matrix(d), pVecWrong)
#' head(DTX)
#'            
choiceDT <- function(data, pVec) {
    .Call('cpda_choiceDT', PACKAGE = 'cpda', data, pVec)
}

#' Compute Log-likelihood Using KDE-based Fast Fourier Transform
#'
#' This function implements Holmes's (2015) KDE-FFT method to calculate
#' approximated probability density. The precision is set at 10 (ie 2^10).
#' \code{logLik_fft2} returns three additional vectors, PDF (discrete
#' probability densities for interpolated empirical data), grid centers, and
#' PDF_hist (discrete probability densities for the simulated data).
#'
#' @param y a vector storing empirical data (e.g., RTs)
#' @param yhat a vector storing simulated data (e.g., simualted RTs, using a
#' LBA model).
#' @return Log-likelihood
#' @references Holmes, W. (2015). A practical guide to the Probability Density
#' Approximation (PDA) with improved implementation and error characterization.
#' \emph{Journal of Mathematical Psychology}, \bold{68-69}, 13--24,
#' doi: http://dx.doi.org/10.1016/j.jmp.2015.08.006.
#' @export
#' @examples
#' ## Use piecewise LBA data as an example
#' data(lba)
#' logLik_fft(plba$DT1, plba$eDT1)
#' logLik_fft(plba$DT2, plba$eDT2)
#' tmp1 <- logLik_fft2(plba$DT1, plba$eDT1)
#' tmp2 <- logLik_fft2(plba$DT2, plba$eDT2)
#'
#' str(tmp1)
#' ## List of 4
#' ## $ LL      : num 278
#' ## $ PDF     : num [1:695, 1] 2.441 0.632 1.966 2.359 2.214 ...
#' ## $ z       : num [1:1024, 1] 0.0889 0.0903 0.0916 0.093 0.0943 ...
#' ## $ PDF_hist: num [1:1024, 1] 0 0 0 0 0 0 0 0 0 0 ...
#' str(tmp2)
#' ## List of 4
#' ## $ LL      : num 42.9
#' ## $ PDF     : num [1:305, 1] 1.879 0.965 1.834 0.326 0.921 ...
#' ## $ z       : num [1:1024, 1] 0.067 0.0696 0.0722 0.0748 0.0774 ...
#' ## $ PDF_hist: num [1:1024, 1] 0 0 0 0 0 0 0 0 0 0 ...
logLik_fft <- function(y, yhat) {
    .Call('cpda_logLik_fft', PACKAGE = 'cpda', y, yhat)
}

#' @rdname logLik_fft
#' @export
logLik_fft2 <- function(y, yhat) {
    .Call('cpda_logLik_fft2', PACKAGE = 'cpda', y, yhat)
}

#' A simple and fast quantile calculator
#'
#' A C++ version quantile function.
#'
#' @param y a data vector
#' @param q nth quantile. Enter proportion, such as .25 or .75.
#' @export
cquantile <- function(y, q) {
    .Call('cpda_cquantile', PACKAGE = 'cpda', y, q)
}

#' Silverman's Rule of Thumb Bandwidth for Kernel Density Estimation
#'
#' A C++ version of Silverman's rule-of-thumb bandwidth. This is similar
#' with R's \code{bw.nrd0(x)}
#'
#' @param y a data vector
#' @param m a multiplier to adjust the SROT proportionally.
#' @export
#' @examples
#' data(lba)
#' h <-cpda::bwNRD0(plba$DT1, 0.8)
#' 
bwNRD0 <- function(y, m) {
    .Call('cpda_bwNRD0', PACKAGE = 'cpda', y, m)
}

